// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __ModelLoader_hh__
#define __ModelLoader_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_ModelLoader
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_ModelLoader
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_ModelLoader
#endif



#ifndef __OpenHRPCommon_hh_EXTERNAL_GUARD__
#define __OpenHRPCommon_hh_EXTERNAL_GUARD__
#include "OpenHRPCommon.hh"
#endif



#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE OpenHRP

_CORBA_MODULE_BEG

  struct TransformedShapeIndex {
    typedef _CORBA_ConstrType_Fix_Var<TransformedShapeIndex> _var_type;

    
    DblArray12 transformMatrix;

    ::CORBA::Short inlinedShapeTransformMatrixIndex;

    ::CORBA::Short shapeIndex;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef TransformedShapeIndex::_var_type TransformedShapeIndex_var;

  typedef TransformedShapeIndex& TransformedShapeIndex_out;

  class TransformedShapeIndexSequence_var;

  class TransformedShapeIndexSequence : public _CORBA_Unbounded_Sequence< TransformedShapeIndex >  {
  public:
    typedef TransformedShapeIndexSequence_var _var_type;
    inline TransformedShapeIndexSequence() {}
    inline TransformedShapeIndexSequence(const TransformedShapeIndexSequence& _s)
      : _CORBA_Unbounded_Sequence< TransformedShapeIndex > (_s) {}

    inline TransformedShapeIndexSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< TransformedShapeIndex > (_max) {}
    inline TransformedShapeIndexSequence(_CORBA_ULong _max, _CORBA_ULong _len, TransformedShapeIndex* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< TransformedShapeIndex > (_max, _len, _val, _rel) {}

  

    inline TransformedShapeIndexSequence& operator = (const TransformedShapeIndexSequence& _s) {
      _CORBA_Unbounded_Sequence< TransformedShapeIndex > ::operator=(_s);
      return *this;
    }
  };

  class TransformedShapeIndexSequence_out;

  class TransformedShapeIndexSequence_var {
  public:
    inline TransformedShapeIndexSequence_var() : _pd_seq(0) {}
    inline TransformedShapeIndexSequence_var(TransformedShapeIndexSequence* _s) : _pd_seq(_s) {}
    inline TransformedShapeIndexSequence_var(const TransformedShapeIndexSequence_var& _s) {
      if( _s._pd_seq )  _pd_seq = new TransformedShapeIndexSequence(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~TransformedShapeIndexSequence_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline TransformedShapeIndexSequence_var& operator = (TransformedShapeIndexSequence* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline TransformedShapeIndexSequence_var& operator = (const TransformedShapeIndexSequence_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new TransformedShapeIndexSequence;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline TransformedShapeIndex& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline TransformedShapeIndexSequence* operator -> () { return _pd_seq; }
    inline const TransformedShapeIndexSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator TransformedShapeIndexSequence& () const { return *_pd_seq; }
#else
    inline operator const TransformedShapeIndexSequence& () const { return *_pd_seq; }
    inline operator TransformedShapeIndexSequence& () { return *_pd_seq; }
#endif
      
    inline const TransformedShapeIndexSequence& in() const { return *_pd_seq; }
    inline TransformedShapeIndexSequence&       inout()    { return *_pd_seq; }
    inline TransformedShapeIndexSequence*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline TransformedShapeIndexSequence* _retn() { TransformedShapeIndexSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class TransformedShapeIndexSequence_out;
    
  private:
    TransformedShapeIndexSequence* _pd_seq;
  };

  class TransformedShapeIndexSequence_out {
  public:
    inline TransformedShapeIndexSequence_out(TransformedShapeIndexSequence*& _s) : _data(_s) { _data = 0; }
    inline TransformedShapeIndexSequence_out(TransformedShapeIndexSequence_var& _s)
      : _data(_s._pd_seq) { _s = (TransformedShapeIndexSequence*) 0; }
    inline TransformedShapeIndexSequence_out(const TransformedShapeIndexSequence_out& _s) : _data(_s._data) {}
    inline TransformedShapeIndexSequence_out& operator = (const TransformedShapeIndexSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline TransformedShapeIndexSequence_out& operator = (TransformedShapeIndexSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator TransformedShapeIndexSequence*&()  { return _data; }
    inline TransformedShapeIndexSequence*& ptr()       { return _data; }
    inline TransformedShapeIndexSequence* operator->() { return _data; }

    inline TransformedShapeIndex& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    TransformedShapeIndexSequence*& _data;

  private:
    TransformedShapeIndexSequence_out();
    TransformedShapeIndexSequence_out& operator=(const TransformedShapeIndexSequence_var&);
  };

  class AllLinkShapeIndexSequence_var;

  class AllLinkShapeIndexSequence : public _CORBA_Unbounded_Sequence< TransformedShapeIndexSequence >  {
  public:
    typedef AllLinkShapeIndexSequence_var _var_type;
    inline AllLinkShapeIndexSequence() {}
    inline AllLinkShapeIndexSequence(const AllLinkShapeIndexSequence& _s)
      : _CORBA_Unbounded_Sequence< TransformedShapeIndexSequence > (_s) {}

    inline AllLinkShapeIndexSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< TransformedShapeIndexSequence > (_max) {}
    inline AllLinkShapeIndexSequence(_CORBA_ULong _max, _CORBA_ULong _len, TransformedShapeIndexSequence* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< TransformedShapeIndexSequence > (_max, _len, _val, _rel) {}

  

    inline AllLinkShapeIndexSequence& operator = (const AllLinkShapeIndexSequence& _s) {
      _CORBA_Unbounded_Sequence< TransformedShapeIndexSequence > ::operator=(_s);
      return *this;
    }
  };

  class AllLinkShapeIndexSequence_out;

  class AllLinkShapeIndexSequence_var {
  public:
    inline AllLinkShapeIndexSequence_var() : _pd_seq(0) {}
    inline AllLinkShapeIndexSequence_var(AllLinkShapeIndexSequence* _s) : _pd_seq(_s) {}
    inline AllLinkShapeIndexSequence_var(const AllLinkShapeIndexSequence_var& _s) {
      if( _s._pd_seq )  _pd_seq = new AllLinkShapeIndexSequence(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~AllLinkShapeIndexSequence_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline AllLinkShapeIndexSequence_var& operator = (AllLinkShapeIndexSequence* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline AllLinkShapeIndexSequence_var& operator = (const AllLinkShapeIndexSequence_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new AllLinkShapeIndexSequence;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline TransformedShapeIndexSequence& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline AllLinkShapeIndexSequence* operator -> () { return _pd_seq; }
    inline const AllLinkShapeIndexSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator AllLinkShapeIndexSequence& () const { return *_pd_seq; }
#else
    inline operator const AllLinkShapeIndexSequence& () const { return *_pd_seq; }
    inline operator AllLinkShapeIndexSequence& () { return *_pd_seq; }
#endif
      
    inline const AllLinkShapeIndexSequence& in() const { return *_pd_seq; }
    inline AllLinkShapeIndexSequence&       inout()    { return *_pd_seq; }
    inline AllLinkShapeIndexSequence*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline AllLinkShapeIndexSequence* _retn() { AllLinkShapeIndexSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class AllLinkShapeIndexSequence_out;
    
  private:
    AllLinkShapeIndexSequence* _pd_seq;
  };

  class AllLinkShapeIndexSequence_out {
  public:
    inline AllLinkShapeIndexSequence_out(AllLinkShapeIndexSequence*& _s) : _data(_s) { _data = 0; }
    inline AllLinkShapeIndexSequence_out(AllLinkShapeIndexSequence_var& _s)
      : _data(_s._pd_seq) { _s = (AllLinkShapeIndexSequence*) 0; }
    inline AllLinkShapeIndexSequence_out(const AllLinkShapeIndexSequence_out& _s) : _data(_s._data) {}
    inline AllLinkShapeIndexSequence_out& operator = (const AllLinkShapeIndexSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline AllLinkShapeIndexSequence_out& operator = (AllLinkShapeIndexSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator AllLinkShapeIndexSequence*&()  { return _data; }
    inline AllLinkShapeIndexSequence*& ptr()       { return _data; }
    inline AllLinkShapeIndexSequence* operator->() { return _data; }

    inline TransformedShapeIndexSequence& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    AllLinkShapeIndexSequence*& _data;

  private:
    AllLinkShapeIndexSequence_out();
    AllLinkShapeIndexSequence_out& operator=(const AllLinkShapeIndexSequence_var&);
  };

  struct SensorInfo {
    typedef _CORBA_ConstrType_Variable_Var<SensorInfo> _var_type;

    
    ::CORBA::String_member type;

    ::CORBA::String_member name;

    ::CORBA::Long id;

    DblArray3 translation;

    DblArray4 rotation;

    FloatSequence specValues;

    ::CORBA::String_member specFile;

    TransformedShapeIndexSequence shapeIndices;

    DblArray12Sequence inlinedShapeTransformMatrices;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef SensorInfo::_var_type SensorInfo_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< SensorInfo,SensorInfo_var > SensorInfo_out;

  class SensorInfoSequence_var;

  class SensorInfoSequence : public _CORBA_Unbounded_Sequence< SensorInfo >  {
  public:
    typedef SensorInfoSequence_var _var_type;
    inline SensorInfoSequence() {}
    inline SensorInfoSequence(const SensorInfoSequence& _s)
      : _CORBA_Unbounded_Sequence< SensorInfo > (_s) {}

    inline SensorInfoSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< SensorInfo > (_max) {}
    inline SensorInfoSequence(_CORBA_ULong _max, _CORBA_ULong _len, SensorInfo* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< SensorInfo > (_max, _len, _val, _rel) {}

  

    inline SensorInfoSequence& operator = (const SensorInfoSequence& _s) {
      _CORBA_Unbounded_Sequence< SensorInfo > ::operator=(_s);
      return *this;
    }
  };

  class SensorInfoSequence_out;

  class SensorInfoSequence_var {
  public:
    inline SensorInfoSequence_var() : _pd_seq(0) {}
    inline SensorInfoSequence_var(SensorInfoSequence* _s) : _pd_seq(_s) {}
    inline SensorInfoSequence_var(const SensorInfoSequence_var& _s) {
      if( _s._pd_seq )  _pd_seq = new SensorInfoSequence(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~SensorInfoSequence_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline SensorInfoSequence_var& operator = (SensorInfoSequence* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline SensorInfoSequence_var& operator = (const SensorInfoSequence_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new SensorInfoSequence;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline SensorInfo& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline SensorInfoSequence* operator -> () { return _pd_seq; }
    inline const SensorInfoSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator SensorInfoSequence& () const { return *_pd_seq; }
#else
    inline operator const SensorInfoSequence& () const { return *_pd_seq; }
    inline operator SensorInfoSequence& () { return *_pd_seq; }
#endif
      
    inline const SensorInfoSequence& in() const { return *_pd_seq; }
    inline SensorInfoSequence&       inout()    { return *_pd_seq; }
    inline SensorInfoSequence*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline SensorInfoSequence* _retn() { SensorInfoSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class SensorInfoSequence_out;
    
  private:
    SensorInfoSequence* _pd_seq;
  };

  class SensorInfoSequence_out {
  public:
    inline SensorInfoSequence_out(SensorInfoSequence*& _s) : _data(_s) { _data = 0; }
    inline SensorInfoSequence_out(SensorInfoSequence_var& _s)
      : _data(_s._pd_seq) { _s = (SensorInfoSequence*) 0; }
    inline SensorInfoSequence_out(const SensorInfoSequence_out& _s) : _data(_s._data) {}
    inline SensorInfoSequence_out& operator = (const SensorInfoSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline SensorInfoSequence_out& operator = (SensorInfoSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator SensorInfoSequence*&()  { return _data; }
    inline SensorInfoSequence*& ptr()       { return _data; }
    inline SensorInfoSequence* operator->() { return _data; }

    inline SensorInfo& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    SensorInfoSequence*& _data;

  private:
    SensorInfoSequence_out();
    SensorInfoSequence_out& operator=(const SensorInfoSequence_var&);
  };

  struct HwcInfo {
    typedef _CORBA_ConstrType_Variable_Var<HwcInfo> _var_type;

    
    ::CORBA::String_member name;

    ::CORBA::Long id;

    DblArray3 translation;

    DblArray4 rotation;

    ::CORBA::String_member url;

    TransformedShapeIndexSequence shapeIndices;

    DblArray12Sequence inlinedShapeTransformMatrices;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef HwcInfo::_var_type HwcInfo_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< HwcInfo,HwcInfo_var > HwcInfo_out;

  class HwcInfoSequence_var;

  class HwcInfoSequence : public _CORBA_Unbounded_Sequence< HwcInfo >  {
  public:
    typedef HwcInfoSequence_var _var_type;
    inline HwcInfoSequence() {}
    inline HwcInfoSequence(const HwcInfoSequence& _s)
      : _CORBA_Unbounded_Sequence< HwcInfo > (_s) {}

    inline HwcInfoSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< HwcInfo > (_max) {}
    inline HwcInfoSequence(_CORBA_ULong _max, _CORBA_ULong _len, HwcInfo* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< HwcInfo > (_max, _len, _val, _rel) {}

  

    inline HwcInfoSequence& operator = (const HwcInfoSequence& _s) {
      _CORBA_Unbounded_Sequence< HwcInfo > ::operator=(_s);
      return *this;
    }
  };

  class HwcInfoSequence_out;

  class HwcInfoSequence_var {
  public:
    inline HwcInfoSequence_var() : _pd_seq(0) {}
    inline HwcInfoSequence_var(HwcInfoSequence* _s) : _pd_seq(_s) {}
    inline HwcInfoSequence_var(const HwcInfoSequence_var& _s) {
      if( _s._pd_seq )  _pd_seq = new HwcInfoSequence(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~HwcInfoSequence_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline HwcInfoSequence_var& operator = (HwcInfoSequence* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline HwcInfoSequence_var& operator = (const HwcInfoSequence_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new HwcInfoSequence;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline HwcInfo& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline HwcInfoSequence* operator -> () { return _pd_seq; }
    inline const HwcInfoSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator HwcInfoSequence& () const { return *_pd_seq; }
#else
    inline operator const HwcInfoSequence& () const { return *_pd_seq; }
    inline operator HwcInfoSequence& () { return *_pd_seq; }
#endif
      
    inline const HwcInfoSequence& in() const { return *_pd_seq; }
    inline HwcInfoSequence&       inout()    { return *_pd_seq; }
    inline HwcInfoSequence*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline HwcInfoSequence* _retn() { HwcInfoSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class HwcInfoSequence_out;
    
  private:
    HwcInfoSequence* _pd_seq;
  };

  class HwcInfoSequence_out {
  public:
    inline HwcInfoSequence_out(HwcInfoSequence*& _s) : _data(_s) { _data = 0; }
    inline HwcInfoSequence_out(HwcInfoSequence_var& _s)
      : _data(_s._pd_seq) { _s = (HwcInfoSequence*) 0; }
    inline HwcInfoSequence_out(const HwcInfoSequence_out& _s) : _data(_s._data) {}
    inline HwcInfoSequence_out& operator = (const HwcInfoSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline HwcInfoSequence_out& operator = (HwcInfoSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator HwcInfoSequence*&()  { return _data; }
    inline HwcInfoSequence*& ptr()       { return _data; }
    inline HwcInfoSequence* operator->() { return _data; }

    inline HwcInfo& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    HwcInfoSequence*& _data;

  private:
    HwcInfoSequence_out();
    HwcInfoSequence_out& operator=(const HwcInfoSequence_var&);
  };

  enum LightType { POINT, DIRECTIONAL, SPOT /*, __max_LightType=0xffffffff */ };
  typedef LightType& LightType_out;

  struct LightInfo {
    typedef _CORBA_ConstrType_Variable_Var<LightInfo> _var_type;

    
    ::CORBA::String_member name;

    LightType type;

    DblArray12 transformMatrix;

    ::CORBA::Double ambientIntensity;

    DblArray3 attenuation;

    DblArray3 color;

    ::CORBA::Double intensity;

    DblArray3 location;

    ::CORBA::Boolean on;

    ::CORBA::Double radius;

    DblArray3 direction;

    ::CORBA::Double beamWidth;

    ::CORBA::Double cutOffAngle;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef LightInfo::_var_type LightInfo_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< LightInfo,LightInfo_var > LightInfo_out;

  class LightInfoSequence_var;

  class LightInfoSequence : public _CORBA_Unbounded_Sequence< LightInfo >  {
  public:
    typedef LightInfoSequence_var _var_type;
    inline LightInfoSequence() {}
    inline LightInfoSequence(const LightInfoSequence& _s)
      : _CORBA_Unbounded_Sequence< LightInfo > (_s) {}

    inline LightInfoSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< LightInfo > (_max) {}
    inline LightInfoSequence(_CORBA_ULong _max, _CORBA_ULong _len, LightInfo* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< LightInfo > (_max, _len, _val, _rel) {}

  

    inline LightInfoSequence& operator = (const LightInfoSequence& _s) {
      _CORBA_Unbounded_Sequence< LightInfo > ::operator=(_s);
      return *this;
    }
  };

  class LightInfoSequence_out;

  class LightInfoSequence_var {
  public:
    inline LightInfoSequence_var() : _pd_seq(0) {}
    inline LightInfoSequence_var(LightInfoSequence* _s) : _pd_seq(_s) {}
    inline LightInfoSequence_var(const LightInfoSequence_var& _s) {
      if( _s._pd_seq )  _pd_seq = new LightInfoSequence(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~LightInfoSequence_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline LightInfoSequence_var& operator = (LightInfoSequence* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline LightInfoSequence_var& operator = (const LightInfoSequence_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new LightInfoSequence;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline LightInfo& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline LightInfoSequence* operator -> () { return _pd_seq; }
    inline const LightInfoSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator LightInfoSequence& () const { return *_pd_seq; }
#else
    inline operator const LightInfoSequence& () const { return *_pd_seq; }
    inline operator LightInfoSequence& () { return *_pd_seq; }
#endif
      
    inline const LightInfoSequence& in() const { return *_pd_seq; }
    inline LightInfoSequence&       inout()    { return *_pd_seq; }
    inline LightInfoSequence*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline LightInfoSequence* _retn() { LightInfoSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class LightInfoSequence_out;
    
  private:
    LightInfoSequence* _pd_seq;
  };

  class LightInfoSequence_out {
  public:
    inline LightInfoSequence_out(LightInfoSequence*& _s) : _data(_s) { _data = 0; }
    inline LightInfoSequence_out(LightInfoSequence_var& _s)
      : _data(_s._pd_seq) { _s = (LightInfoSequence*) 0; }
    inline LightInfoSequence_out(const LightInfoSequence_out& _s) : _data(_s._data) {}
    inline LightInfoSequence_out& operator = (const LightInfoSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline LightInfoSequence_out& operator = (LightInfoSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator LightInfoSequence*&()  { return _data; }
    inline LightInfoSequence*& ptr()       { return _data; }
    inline LightInfoSequence* operator->() { return _data; }

    inline LightInfo& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    LightInfoSequence*& _data;

  private:
    LightInfoSequence_out();
    LightInfoSequence_out& operator=(const LightInfoSequence_var&);
  };

  struct SegmentInfo {
    typedef _CORBA_ConstrType_Variable_Var<SegmentInfo> _var_type;

    
    ::CORBA::String_member name;

    ::CORBA::Double mass;

    DblArray3 centerOfMass;

    DblArray9 inertia;

    DblArray12 transformMatrix;

    typedef _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Short, 2, 2 >  _shapeIndices_seq;
    _shapeIndices_seq shapeIndices;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef SegmentInfo::_var_type SegmentInfo_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< SegmentInfo,SegmentInfo_var > SegmentInfo_out;

  class SegmentInfoSequence_var;

  class SegmentInfoSequence : public _CORBA_Unbounded_Sequence< SegmentInfo >  {
  public:
    typedef SegmentInfoSequence_var _var_type;
    inline SegmentInfoSequence() {}
    inline SegmentInfoSequence(const SegmentInfoSequence& _s)
      : _CORBA_Unbounded_Sequence< SegmentInfo > (_s) {}

    inline SegmentInfoSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< SegmentInfo > (_max) {}
    inline SegmentInfoSequence(_CORBA_ULong _max, _CORBA_ULong _len, SegmentInfo* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< SegmentInfo > (_max, _len, _val, _rel) {}

  

    inline SegmentInfoSequence& operator = (const SegmentInfoSequence& _s) {
      _CORBA_Unbounded_Sequence< SegmentInfo > ::operator=(_s);
      return *this;
    }
  };

  class SegmentInfoSequence_out;

  class SegmentInfoSequence_var {
  public:
    inline SegmentInfoSequence_var() : _pd_seq(0) {}
    inline SegmentInfoSequence_var(SegmentInfoSequence* _s) : _pd_seq(_s) {}
    inline SegmentInfoSequence_var(const SegmentInfoSequence_var& _s) {
      if( _s._pd_seq )  _pd_seq = new SegmentInfoSequence(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~SegmentInfoSequence_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline SegmentInfoSequence_var& operator = (SegmentInfoSequence* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline SegmentInfoSequence_var& operator = (const SegmentInfoSequence_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new SegmentInfoSequence;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline SegmentInfo& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline SegmentInfoSequence* operator -> () { return _pd_seq; }
    inline const SegmentInfoSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator SegmentInfoSequence& () const { return *_pd_seq; }
#else
    inline operator const SegmentInfoSequence& () const { return *_pd_seq; }
    inline operator SegmentInfoSequence& () { return *_pd_seq; }
#endif
      
    inline const SegmentInfoSequence& in() const { return *_pd_seq; }
    inline SegmentInfoSequence&       inout()    { return *_pd_seq; }
    inline SegmentInfoSequence*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline SegmentInfoSequence* _retn() { SegmentInfoSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class SegmentInfoSequence_out;
    
  private:
    SegmentInfoSequence* _pd_seq;
  };

  class SegmentInfoSequence_out {
  public:
    inline SegmentInfoSequence_out(SegmentInfoSequence*& _s) : _data(_s) { _data = 0; }
    inline SegmentInfoSequence_out(SegmentInfoSequence_var& _s)
      : _data(_s._pd_seq) { _s = (SegmentInfoSequence*) 0; }
    inline SegmentInfoSequence_out(const SegmentInfoSequence_out& _s) : _data(_s._data) {}
    inline SegmentInfoSequence_out& operator = (const SegmentInfoSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline SegmentInfoSequence_out& operator = (SegmentInfoSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator SegmentInfoSequence*&()  { return _data; }
    inline SegmentInfoSequence*& ptr()       { return _data; }
    inline SegmentInfoSequence* operator->() { return _data; }

    inline SegmentInfo& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    SegmentInfoSequence*& _data;

  private:
    SegmentInfoSequence_out();
    SegmentInfoSequence_out& operator=(const SegmentInfoSequence_var&);
  };

  struct LinkInfo {
    typedef _CORBA_ConstrType_Variable_Var<LinkInfo> _var_type;

    
    ::CORBA::String_member name;

    ::CORBA::Short jointId;

    ::CORBA::String_member jointType;

    ::CORBA::Double jointValue;

    DblArray3 jointAxis;

    DblSequence ulimit;

    DblSequence llimit;

    DblSequence uvlimit;

    DblSequence lvlimit;

    DblSequence tlimit;

    DblArray3 translation;

    DblArray4 rotation;

    ::CORBA::Double mass;

    DblArray3 centerOfMass;

    DblArray9 inertia;

    ::CORBA::Double rotorInertia;

    ::CORBA::Double rotorResistor;

    ::CORBA::Double gearRatio;

    ::CORBA::Double torqueConst;

    ::CORBA::Double encoderPulse;

    ::CORBA::Short parentIndex;

    ShortSequence childIndices;

    TransformedShapeIndexSequence shapeIndices;

    ::CORBA::Short AABBmaxDepth;

    ::CORBA::Short AABBmaxNum;

    DblArray12Sequence inlinedShapeTransformMatrices;

    SensorInfoSequence sensors;

    HwcInfoSequence hwcs;

    SegmentInfoSequence segments;

    LightInfoSequence lights;

    StringSequence specFiles;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef LinkInfo::_var_type LinkInfo_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< LinkInfo,LinkInfo_var > LinkInfo_out;

  class LinkInfoSequence_var;

  class LinkInfoSequence : public _CORBA_Unbounded_Sequence< LinkInfo >  {
  public:
    typedef LinkInfoSequence_var _var_type;
    inline LinkInfoSequence() {}
    inline LinkInfoSequence(const LinkInfoSequence& _s)
      : _CORBA_Unbounded_Sequence< LinkInfo > (_s) {}

    inline LinkInfoSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< LinkInfo > (_max) {}
    inline LinkInfoSequence(_CORBA_ULong _max, _CORBA_ULong _len, LinkInfo* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< LinkInfo > (_max, _len, _val, _rel) {}

  

    inline LinkInfoSequence& operator = (const LinkInfoSequence& _s) {
      _CORBA_Unbounded_Sequence< LinkInfo > ::operator=(_s);
      return *this;
    }
  };

  class LinkInfoSequence_out;

  class LinkInfoSequence_var {
  public:
    inline LinkInfoSequence_var() : _pd_seq(0) {}
    inline LinkInfoSequence_var(LinkInfoSequence* _s) : _pd_seq(_s) {}
    inline LinkInfoSequence_var(const LinkInfoSequence_var& _s) {
      if( _s._pd_seq )  _pd_seq = new LinkInfoSequence(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~LinkInfoSequence_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline LinkInfoSequence_var& operator = (LinkInfoSequence* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline LinkInfoSequence_var& operator = (const LinkInfoSequence_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new LinkInfoSequence;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline LinkInfo& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline LinkInfoSequence* operator -> () { return _pd_seq; }
    inline const LinkInfoSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator LinkInfoSequence& () const { return *_pd_seq; }
#else
    inline operator const LinkInfoSequence& () const { return *_pd_seq; }
    inline operator LinkInfoSequence& () { return *_pd_seq; }
#endif
      
    inline const LinkInfoSequence& in() const { return *_pd_seq; }
    inline LinkInfoSequence&       inout()    { return *_pd_seq; }
    inline LinkInfoSequence*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline LinkInfoSequence* _retn() { LinkInfoSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class LinkInfoSequence_out;
    
  private:
    LinkInfoSequence* _pd_seq;
  };

  class LinkInfoSequence_out {
  public:
    inline LinkInfoSequence_out(LinkInfoSequence*& _s) : _data(_s) { _data = 0; }
    inline LinkInfoSequence_out(LinkInfoSequence_var& _s)
      : _data(_s._pd_seq) { _s = (LinkInfoSequence*) 0; }
    inline LinkInfoSequence_out(const LinkInfoSequence_out& _s) : _data(_s._data) {}
    inline LinkInfoSequence_out& operator = (const LinkInfoSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline LinkInfoSequence_out& operator = (LinkInfoSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator LinkInfoSequence*&()  { return _data; }
    inline LinkInfoSequence*& ptr()       { return _data; }
    inline LinkInfoSequence* operator->() { return _data; }

    inline LinkInfo& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    LinkInfoSequence*& _data;

  private:
    LinkInfoSequence_out();
    LinkInfoSequence_out& operator=(const LinkInfoSequence_var&);
  };

  enum ShapePrimitiveType { SP_MESH, SP_BOX, SP_CYLINDER, SP_CONE, SP_SPHERE, SP_PLANE /*, __max_ShapePrimitiveType=0xffffffff */ };
  typedef ShapePrimitiveType& ShapePrimitiveType_out;

  struct ShapeInfo {
    typedef _CORBA_ConstrType_Variable_Var<ShapeInfo> _var_type;

    
    ::CORBA::String_member url;

    ShapePrimitiveType primitiveType;

    FloatSequence primitiveParameters;

    FloatSequence vertices;

    LongSequence triangles;

    ::CORBA::Long appearanceIndex;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ShapeInfo::_var_type ShapeInfo_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< ShapeInfo,ShapeInfo_var > ShapeInfo_out;

  class ShapeInfoSequence_var;

  class ShapeInfoSequence : public _CORBA_Unbounded_Sequence< ShapeInfo >  {
  public:
    typedef ShapeInfoSequence_var _var_type;
    inline ShapeInfoSequence() {}
    inline ShapeInfoSequence(const ShapeInfoSequence& _s)
      : _CORBA_Unbounded_Sequence< ShapeInfo > (_s) {}

    inline ShapeInfoSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< ShapeInfo > (_max) {}
    inline ShapeInfoSequence(_CORBA_ULong _max, _CORBA_ULong _len, ShapeInfo* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< ShapeInfo > (_max, _len, _val, _rel) {}

  

    inline ShapeInfoSequence& operator = (const ShapeInfoSequence& _s) {
      _CORBA_Unbounded_Sequence< ShapeInfo > ::operator=(_s);
      return *this;
    }
  };

  class ShapeInfoSequence_out;

  class ShapeInfoSequence_var {
  public:
    inline ShapeInfoSequence_var() : _pd_seq(0) {}
    inline ShapeInfoSequence_var(ShapeInfoSequence* _s) : _pd_seq(_s) {}
    inline ShapeInfoSequence_var(const ShapeInfoSequence_var& _s) {
      if( _s._pd_seq )  _pd_seq = new ShapeInfoSequence(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~ShapeInfoSequence_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline ShapeInfoSequence_var& operator = (ShapeInfoSequence* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline ShapeInfoSequence_var& operator = (const ShapeInfoSequence_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new ShapeInfoSequence;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ShapeInfo& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline ShapeInfoSequence* operator -> () { return _pd_seq; }
    inline const ShapeInfoSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator ShapeInfoSequence& () const { return *_pd_seq; }
#else
    inline operator const ShapeInfoSequence& () const { return *_pd_seq; }
    inline operator ShapeInfoSequence& () { return *_pd_seq; }
#endif
      
    inline const ShapeInfoSequence& in() const { return *_pd_seq; }
    inline ShapeInfoSequence&       inout()    { return *_pd_seq; }
    inline ShapeInfoSequence*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline ShapeInfoSequence* _retn() { ShapeInfoSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class ShapeInfoSequence_out;
    
  private:
    ShapeInfoSequence* _pd_seq;
  };

  class ShapeInfoSequence_out {
  public:
    inline ShapeInfoSequence_out(ShapeInfoSequence*& _s) : _data(_s) { _data = 0; }
    inline ShapeInfoSequence_out(ShapeInfoSequence_var& _s)
      : _data(_s._pd_seq) { _s = (ShapeInfoSequence*) 0; }
    inline ShapeInfoSequence_out(const ShapeInfoSequence_out& _s) : _data(_s._data) {}
    inline ShapeInfoSequence_out& operator = (const ShapeInfoSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline ShapeInfoSequence_out& operator = (ShapeInfoSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator ShapeInfoSequence*&()  { return _data; }
    inline ShapeInfoSequence*& ptr()       { return _data; }
    inline ShapeInfoSequence* operator->() { return _data; }

    inline ShapeInfo& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    ShapeInfoSequence*& _data;

  private:
    ShapeInfoSequence_out();
    ShapeInfoSequence_out& operator=(const ShapeInfoSequence_var&);
  };

  struct AppearanceInfo {
    typedef _CORBA_ConstrType_Variable_Var<AppearanceInfo> _var_type;

    
    ::CORBA::Long materialIndex;

    FloatSequence normals;

    LongSequence normalIndices;

    ::CORBA::Boolean normalPerVertex;

    ::CORBA::Boolean solid;

    ::CORBA::Float creaseAngle;

    FloatSequence colors;

    LongSequence colorIndices;

    ::CORBA::Boolean colorPerVertex;

    ::CORBA::Long textureIndex;

    FloatSequence textureCoordinate;

    LongSequence textureCoordIndices;

    DblArray9 textransformMatrix;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef AppearanceInfo::_var_type AppearanceInfo_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< AppearanceInfo,AppearanceInfo_var > AppearanceInfo_out;

  class AppearanceInfoSequence_var;

  class AppearanceInfoSequence : public _CORBA_Unbounded_Sequence< AppearanceInfo >  {
  public:
    typedef AppearanceInfoSequence_var _var_type;
    inline AppearanceInfoSequence() {}
    inline AppearanceInfoSequence(const AppearanceInfoSequence& _s)
      : _CORBA_Unbounded_Sequence< AppearanceInfo > (_s) {}

    inline AppearanceInfoSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< AppearanceInfo > (_max) {}
    inline AppearanceInfoSequence(_CORBA_ULong _max, _CORBA_ULong _len, AppearanceInfo* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< AppearanceInfo > (_max, _len, _val, _rel) {}

  

    inline AppearanceInfoSequence& operator = (const AppearanceInfoSequence& _s) {
      _CORBA_Unbounded_Sequence< AppearanceInfo > ::operator=(_s);
      return *this;
    }
  };

  class AppearanceInfoSequence_out;

  class AppearanceInfoSequence_var {
  public:
    inline AppearanceInfoSequence_var() : _pd_seq(0) {}
    inline AppearanceInfoSequence_var(AppearanceInfoSequence* _s) : _pd_seq(_s) {}
    inline AppearanceInfoSequence_var(const AppearanceInfoSequence_var& _s) {
      if( _s._pd_seq )  _pd_seq = new AppearanceInfoSequence(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~AppearanceInfoSequence_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline AppearanceInfoSequence_var& operator = (AppearanceInfoSequence* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline AppearanceInfoSequence_var& operator = (const AppearanceInfoSequence_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new AppearanceInfoSequence;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline AppearanceInfo& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline AppearanceInfoSequence* operator -> () { return _pd_seq; }
    inline const AppearanceInfoSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator AppearanceInfoSequence& () const { return *_pd_seq; }
#else
    inline operator const AppearanceInfoSequence& () const { return *_pd_seq; }
    inline operator AppearanceInfoSequence& () { return *_pd_seq; }
#endif
      
    inline const AppearanceInfoSequence& in() const { return *_pd_seq; }
    inline AppearanceInfoSequence&       inout()    { return *_pd_seq; }
    inline AppearanceInfoSequence*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline AppearanceInfoSequence* _retn() { AppearanceInfoSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class AppearanceInfoSequence_out;
    
  private:
    AppearanceInfoSequence* _pd_seq;
  };

  class AppearanceInfoSequence_out {
  public:
    inline AppearanceInfoSequence_out(AppearanceInfoSequence*& _s) : _data(_s) { _data = 0; }
    inline AppearanceInfoSequence_out(AppearanceInfoSequence_var& _s)
      : _data(_s._pd_seq) { _s = (AppearanceInfoSequence*) 0; }
    inline AppearanceInfoSequence_out(const AppearanceInfoSequence_out& _s) : _data(_s._data) {}
    inline AppearanceInfoSequence_out& operator = (const AppearanceInfoSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline AppearanceInfoSequence_out& operator = (AppearanceInfoSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator AppearanceInfoSequence*&()  { return _data; }
    inline AppearanceInfoSequence*& ptr()       { return _data; }
    inline AppearanceInfoSequence* operator->() { return _data; }

    inline AppearanceInfo& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    AppearanceInfoSequence*& _data;

  private:
    AppearanceInfoSequence_out();
    AppearanceInfoSequence_out& operator=(const AppearanceInfoSequence_var&);
  };

  struct MaterialInfo {
    typedef _CORBA_ConstrType_Fix_Var<MaterialInfo> _var_type;

    
    ::CORBA::Float ambientIntensity;

    FloatArray3 diffuseColor;

    FloatArray3 emissiveColor;

    ::CORBA::Float shininess;

    FloatArray3 specularColor;

    ::CORBA::Float transparency;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef MaterialInfo::_var_type MaterialInfo_var;

  typedef MaterialInfo& MaterialInfo_out;

  class MaterialInfoSequence_var;

  class MaterialInfoSequence : public _CORBA_Unbounded_Sequence< MaterialInfo >  {
  public:
    typedef MaterialInfoSequence_var _var_type;
    inline MaterialInfoSequence() {}
    inline MaterialInfoSequence(const MaterialInfoSequence& _s)
      : _CORBA_Unbounded_Sequence< MaterialInfo > (_s) {}

    inline MaterialInfoSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< MaterialInfo > (_max) {}
    inline MaterialInfoSequence(_CORBA_ULong _max, _CORBA_ULong _len, MaterialInfo* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< MaterialInfo > (_max, _len, _val, _rel) {}

  

    inline MaterialInfoSequence& operator = (const MaterialInfoSequence& _s) {
      _CORBA_Unbounded_Sequence< MaterialInfo > ::operator=(_s);
      return *this;
    }
  };

  class MaterialInfoSequence_out;

  class MaterialInfoSequence_var {
  public:
    inline MaterialInfoSequence_var() : _pd_seq(0) {}
    inline MaterialInfoSequence_var(MaterialInfoSequence* _s) : _pd_seq(_s) {}
    inline MaterialInfoSequence_var(const MaterialInfoSequence_var& _s) {
      if( _s._pd_seq )  _pd_seq = new MaterialInfoSequence(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~MaterialInfoSequence_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline MaterialInfoSequence_var& operator = (MaterialInfoSequence* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline MaterialInfoSequence_var& operator = (const MaterialInfoSequence_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new MaterialInfoSequence;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline MaterialInfo& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline MaterialInfoSequence* operator -> () { return _pd_seq; }
    inline const MaterialInfoSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator MaterialInfoSequence& () const { return *_pd_seq; }
#else
    inline operator const MaterialInfoSequence& () const { return *_pd_seq; }
    inline operator MaterialInfoSequence& () { return *_pd_seq; }
#endif
      
    inline const MaterialInfoSequence& in() const { return *_pd_seq; }
    inline MaterialInfoSequence&       inout()    { return *_pd_seq; }
    inline MaterialInfoSequence*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline MaterialInfoSequence* _retn() { MaterialInfoSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class MaterialInfoSequence_out;
    
  private:
    MaterialInfoSequence* _pd_seq;
  };

  class MaterialInfoSequence_out {
  public:
    inline MaterialInfoSequence_out(MaterialInfoSequence*& _s) : _data(_s) { _data = 0; }
    inline MaterialInfoSequence_out(MaterialInfoSequence_var& _s)
      : _data(_s._pd_seq) { _s = (MaterialInfoSequence*) 0; }
    inline MaterialInfoSequence_out(const MaterialInfoSequence_out& _s) : _data(_s._data) {}
    inline MaterialInfoSequence_out& operator = (const MaterialInfoSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline MaterialInfoSequence_out& operator = (MaterialInfoSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator MaterialInfoSequence*&()  { return _data; }
    inline MaterialInfoSequence*& ptr()       { return _data; }
    inline MaterialInfoSequence* operator->() { return _data; }

    inline MaterialInfo& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    MaterialInfoSequence*& _data;

  private:
    MaterialInfoSequence_out();
    MaterialInfoSequence_out& operator=(const MaterialInfoSequence_var&);
  };

  struct TextureInfo {
    typedef _CORBA_ConstrType_Variable_Var<TextureInfo> _var_type;

    
    OctetSequence image;

    ::CORBA::Short numComponents;

    ::CORBA::Short width;

    ::CORBA::Short height;

    ::CORBA::Boolean repeatS;

    ::CORBA::Boolean repeatT;

    ::CORBA::String_member url;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef TextureInfo::_var_type TextureInfo_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< TextureInfo,TextureInfo_var > TextureInfo_out;

  class TextureInfoSequence_var;

  class TextureInfoSequence : public _CORBA_Unbounded_Sequence< TextureInfo >  {
  public:
    typedef TextureInfoSequence_var _var_type;
    inline TextureInfoSequence() {}
    inline TextureInfoSequence(const TextureInfoSequence& _s)
      : _CORBA_Unbounded_Sequence< TextureInfo > (_s) {}

    inline TextureInfoSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< TextureInfo > (_max) {}
    inline TextureInfoSequence(_CORBA_ULong _max, _CORBA_ULong _len, TextureInfo* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< TextureInfo > (_max, _len, _val, _rel) {}

  

    inline TextureInfoSequence& operator = (const TextureInfoSequence& _s) {
      _CORBA_Unbounded_Sequence< TextureInfo > ::operator=(_s);
      return *this;
    }
  };

  class TextureInfoSequence_out;

  class TextureInfoSequence_var {
  public:
    inline TextureInfoSequence_var() : _pd_seq(0) {}
    inline TextureInfoSequence_var(TextureInfoSequence* _s) : _pd_seq(_s) {}
    inline TextureInfoSequence_var(const TextureInfoSequence_var& _s) {
      if( _s._pd_seq )  _pd_seq = new TextureInfoSequence(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~TextureInfoSequence_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline TextureInfoSequence_var& operator = (TextureInfoSequence* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline TextureInfoSequence_var& operator = (const TextureInfoSequence_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new TextureInfoSequence;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline TextureInfo& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline TextureInfoSequence* operator -> () { return _pd_seq; }
    inline const TextureInfoSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator TextureInfoSequence& () const { return *_pd_seq; }
#else
    inline operator const TextureInfoSequence& () const { return *_pd_seq; }
    inline operator TextureInfoSequence& () { return *_pd_seq; }
#endif
      
    inline const TextureInfoSequence& in() const { return *_pd_seq; }
    inline TextureInfoSequence&       inout()    { return *_pd_seq; }
    inline TextureInfoSequence*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline TextureInfoSequence* _retn() { TextureInfoSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class TextureInfoSequence_out;
    
  private:
    TextureInfoSequence* _pd_seq;
  };

  class TextureInfoSequence_out {
  public:
    inline TextureInfoSequence_out(TextureInfoSequence*& _s) : _data(_s) { _data = 0; }
    inline TextureInfoSequence_out(TextureInfoSequence_var& _s)
      : _data(_s._pd_seq) { _s = (TextureInfoSequence*) 0; }
    inline TextureInfoSequence_out(const TextureInfoSequence_out& _s) : _data(_s._data) {}
    inline TextureInfoSequence_out& operator = (const TextureInfoSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline TextureInfoSequence_out& operator = (TextureInfoSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator TextureInfoSequence*&()  { return _data; }
    inline TextureInfoSequence*& ptr()       { return _data; }
    inline TextureInfoSequence* operator->() { return _data; }

    inline TextureInfo& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    TextureInfoSequence*& _data;

  private:
    TextureInfoSequence_out();
    TextureInfoSequence_out& operator=(const TextureInfoSequence_var&);
  };

  struct ExtraJointInfo {
    typedef _CORBA_ConstrType_Variable_Var<ExtraJointInfo> _var_type;

    
    ::CORBA::String_member name;

    ExtraJointType jointType;

    DblArray3 axis;

    typedef ::CORBA::String_member _0RL_link[2];
    typedef ::CORBA::String_member _link_slice;

    ::CORBA::String_member link[2];

    typedef DblArray3 _0RL_point[2];
    typedef DblArray3 _point_slice;

    DblArray3 point[2];

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ExtraJointInfo::_var_type ExtraJointInfo_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< ExtraJointInfo,ExtraJointInfo_var > ExtraJointInfo_out;

  class ExtraJointInfoSequence_var;

  class ExtraJointInfoSequence : public _CORBA_Unbounded_Sequence< ExtraJointInfo >  {
  public:
    typedef ExtraJointInfoSequence_var _var_type;
    inline ExtraJointInfoSequence() {}
    inline ExtraJointInfoSequence(const ExtraJointInfoSequence& _s)
      : _CORBA_Unbounded_Sequence< ExtraJointInfo > (_s) {}

    inline ExtraJointInfoSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< ExtraJointInfo > (_max) {}
    inline ExtraJointInfoSequence(_CORBA_ULong _max, _CORBA_ULong _len, ExtraJointInfo* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< ExtraJointInfo > (_max, _len, _val, _rel) {}

  

    inline ExtraJointInfoSequence& operator = (const ExtraJointInfoSequence& _s) {
      _CORBA_Unbounded_Sequence< ExtraJointInfo > ::operator=(_s);
      return *this;
    }
  };

  class ExtraJointInfoSequence_out;

  class ExtraJointInfoSequence_var {
  public:
    inline ExtraJointInfoSequence_var() : _pd_seq(0) {}
    inline ExtraJointInfoSequence_var(ExtraJointInfoSequence* _s) : _pd_seq(_s) {}
    inline ExtraJointInfoSequence_var(const ExtraJointInfoSequence_var& _s) {
      if( _s._pd_seq )  _pd_seq = new ExtraJointInfoSequence(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~ExtraJointInfoSequence_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline ExtraJointInfoSequence_var& operator = (ExtraJointInfoSequence* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline ExtraJointInfoSequence_var& operator = (const ExtraJointInfoSequence_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new ExtraJointInfoSequence;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ExtraJointInfo& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline ExtraJointInfoSequence* operator -> () { return _pd_seq; }
    inline const ExtraJointInfoSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator ExtraJointInfoSequence& () const { return *_pd_seq; }
#else
    inline operator const ExtraJointInfoSequence& () const { return *_pd_seq; }
    inline operator ExtraJointInfoSequence& () { return *_pd_seq; }
#endif
      
    inline const ExtraJointInfoSequence& in() const { return *_pd_seq; }
    inline ExtraJointInfoSequence&       inout()    { return *_pd_seq; }
    inline ExtraJointInfoSequence*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline ExtraJointInfoSequence* _retn() { ExtraJointInfoSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class ExtraJointInfoSequence_out;
    
  private:
    ExtraJointInfoSequence* _pd_seq;
  };

  class ExtraJointInfoSequence_out {
  public:
    inline ExtraJointInfoSequence_out(ExtraJointInfoSequence*& _s) : _data(_s) { _data = 0; }
    inline ExtraJointInfoSequence_out(ExtraJointInfoSequence_var& _s)
      : _data(_s._pd_seq) { _s = (ExtraJointInfoSequence*) 0; }
    inline ExtraJointInfoSequence_out(const ExtraJointInfoSequence_out& _s) : _data(_s._data) {}
    inline ExtraJointInfoSequence_out& operator = (const ExtraJointInfoSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline ExtraJointInfoSequence_out& operator = (ExtraJointInfoSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator ExtraJointInfoSequence*&()  { return _data; }
    inline ExtraJointInfoSequence*& ptr()       { return _data; }
    inline ExtraJointInfoSequence* operator->() { return _data; }

    inline ExtraJointInfo& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    ExtraJointInfoSequence*& _data;

  private:
    ExtraJointInfoSequence_out();
    ExtraJointInfoSequence_out& operator=(const ExtraJointInfoSequence_var&);
  };

#ifndef __OpenHRP_mShapeSetInfo__
#define __OpenHRP_mShapeSetInfo__

  class ShapeSetInfo;
  class _objref_ShapeSetInfo;
  class _impl_ShapeSetInfo;
  
  typedef _objref_ShapeSetInfo* ShapeSetInfo_ptr;
  typedef ShapeSetInfo_ptr ShapeSetInfoRef;

  class ShapeSetInfo_Helper {
  public:
    typedef ShapeSetInfo_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ShapeSetInfo, ShapeSetInfo_Helper> ShapeSetInfo_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ShapeSetInfo,ShapeSetInfo_Helper > ShapeSetInfo_out;

#endif

  // interface ShapeSetInfo
  class ShapeSetInfo {
  public:
    // Declarations for this interface type.
    typedef ShapeSetInfo_ptr _ptr_type;
    typedef ShapeSetInfo_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_ShapeSetInfo :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    ShapeInfoSequence* shapes();
    AppearanceInfoSequence* appearances();
    MaterialInfoSequence* materials();
    TextureInfoSequence* textures();

    inline _objref_ShapeSetInfo()  { _PR_setobj(0); }  // nil
    _objref_ShapeSetInfo(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ShapeSetInfo();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ShapeSetInfo(const _objref_ShapeSetInfo&);
    _objref_ShapeSetInfo& operator = (const _objref_ShapeSetInfo&);
    // not implemented

    friend class ShapeSetInfo;
  };

  class _pof_ShapeSetInfo : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ShapeSetInfo() : _OMNI_NS(proxyObjectFactory)(ShapeSetInfo::_PD_repoId) {}
    virtual ~_pof_ShapeSetInfo();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ShapeSetInfo :
    public virtual omniServant
  {
  public:
    virtual ~_impl_ShapeSetInfo();

    virtual ShapeInfoSequence* shapes() = 0;
    virtual AppearanceInfoSequence* appearances() = 0;
    virtual MaterialInfoSequence* materials() = 0;
    virtual TextureInfoSequence* textures() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


#ifndef __OpenHRP_mBodyInfo__
#define __OpenHRP_mBodyInfo__

  class BodyInfo;
  class _objref_BodyInfo;
  class _impl_BodyInfo;
  
  typedef _objref_BodyInfo* BodyInfo_ptr;
  typedef BodyInfo_ptr BodyInfoRef;

  class BodyInfo_Helper {
  public:
    typedef BodyInfo_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_BodyInfo, BodyInfo_Helper> BodyInfo_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_BodyInfo,BodyInfo_Helper > BodyInfo_out;

#endif

  // interface BodyInfo
  class BodyInfo {
  public:
    // Declarations for this interface type.
    typedef BodyInfo_ptr _ptr_type;
    typedef BodyInfo_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_BodyInfo :
    public virtual _objref_ShapeSetInfo
  {
  public:
    char* name();
    char* url();
    StringSequence* info();
    LinkInfoSequence* links();
    AllLinkShapeIndexSequence* linkShapeIndices();
    ExtraJointInfoSequence* extraJoints();

    inline _objref_BodyInfo()  { _PR_setobj(0); }  // nil
    _objref_BodyInfo(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_BodyInfo();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_BodyInfo(const _objref_BodyInfo&);
    _objref_BodyInfo& operator = (const _objref_BodyInfo&);
    // not implemented

    friend class BodyInfo;
  };

  class _pof_BodyInfo : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_BodyInfo() : _OMNI_NS(proxyObjectFactory)(BodyInfo::_PD_repoId) {}
    virtual ~_pof_BodyInfo();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_BodyInfo :
    public virtual _impl_ShapeSetInfo
  {
  public:
    virtual ~_impl_BodyInfo();

    virtual char* name() = 0;
    virtual char* url() = 0;
    virtual StringSequence* info() = 0;
    virtual LinkInfoSequence* links() = 0;
    virtual AllLinkShapeIndexSequence* linkShapeIndices() = 0;
    virtual ExtraJointInfoSequence* extraJoints() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


#ifndef __OpenHRP_mSceneInfo__
#define __OpenHRP_mSceneInfo__

  class SceneInfo;
  class _objref_SceneInfo;
  class _impl_SceneInfo;
  
  typedef _objref_SceneInfo* SceneInfo_ptr;
  typedef SceneInfo_ptr SceneInfoRef;

  class SceneInfo_Helper {
  public:
    typedef SceneInfo_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_SceneInfo, SceneInfo_Helper> SceneInfo_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_SceneInfo,SceneInfo_Helper > SceneInfo_out;

#endif

  // interface SceneInfo
  class SceneInfo {
  public:
    // Declarations for this interface type.
    typedef SceneInfo_ptr _ptr_type;
    typedef SceneInfo_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_SceneInfo :
    public virtual _objref_ShapeSetInfo
  {
  public:
    char* url();
    TransformedShapeIndexSequence* shapeIndices();

    inline _objref_SceneInfo()  { _PR_setobj(0); }  // nil
    _objref_SceneInfo(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_SceneInfo();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_SceneInfo(const _objref_SceneInfo&);
    _objref_SceneInfo& operator = (const _objref_SceneInfo&);
    // not implemented

    friend class SceneInfo;
  };

  class _pof_SceneInfo : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_SceneInfo() : _OMNI_NS(proxyObjectFactory)(SceneInfo::_PD_repoId) {}
    virtual ~_pof_SceneInfo();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_SceneInfo :
    public virtual _impl_ShapeSetInfo
  {
  public:
    virtual ~_impl_SceneInfo();

    virtual char* url() = 0;
    virtual TransformedShapeIndexSequence* shapeIndices() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


#ifndef __OpenHRP_mModelLoader__
#define __OpenHRP_mModelLoader__

  class ModelLoader;
  class _objref_ModelLoader;
  class _impl_ModelLoader;
  
  typedef _objref_ModelLoader* ModelLoader_ptr;
  typedef ModelLoader_ptr ModelLoaderRef;

  class ModelLoader_Helper {
  public:
    typedef ModelLoader_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ModelLoader, ModelLoader_Helper> ModelLoader_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ModelLoader,ModelLoader_Helper > ModelLoader_out;

#endif

  // interface ModelLoader
  class ModelLoader {
  public:
    // Declarations for this interface type.
    typedef ModelLoader_ptr _ptr_type;
    typedef ModelLoader_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    class ModelLoaderException : public ::CORBA::UserException {
    public:
      
      ::CORBA::String_member description;

    

      inline ModelLoaderException() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      ModelLoaderException(const ModelLoaderException&);
      ModelLoaderException(const char* i_description);
      ModelLoaderException& operator=(const ModelLoaderException&);
      virtual ~ModelLoaderException();
      virtual void _raise() const;
      static ModelLoaderException* _downcast(::CORBA::Exception*);
      static const ModelLoaderException* _downcast(const ::CORBA::Exception*);
      static inline ModelLoaderException* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    enum AABBdataType { AABB_DEPTH, AABB_NUM /*, __max_AABBdataType=0xffffffff */ };
    typedef AABBdataType& AABBdataType_out;

    struct ModelLoadOption {
      typedef _CORBA_ConstrType_Variable_Var<ModelLoadOption> _var_type;

      
      ::CORBA::Boolean readImage;

      ShortSequence AABBdata;

      AABBdataType AABBtype;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef ModelLoadOption::_var_type ModelLoadOption_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< ModelLoadOption,ModelLoadOption_var > ModelLoadOption_out;

  
  };

  class _objref_ModelLoader :
    public virtual _objref_ServerObject
  {
  public:
    BodyInfo_ptr getBodyInfo(const char* url);
    BodyInfo_ptr getBodyInfoEx(const char* url, const ::OpenHRP::ModelLoader::ModelLoadOption& option);
    BodyInfo_ptr loadBodyInfo(const char* url);
    BodyInfo_ptr loadBodyInfoEx(const char* url, const ::OpenHRP::ModelLoader::ModelLoadOption& option);
    SceneInfo_ptr loadSceneInfo(const char* url);
    void clearData();

    inline _objref_ModelLoader()  { _PR_setobj(0); }  // nil
    _objref_ModelLoader(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ModelLoader();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ModelLoader(const _objref_ModelLoader&);
    _objref_ModelLoader& operator = (const _objref_ModelLoader&);
    // not implemented

    friend class ModelLoader;
  };

  class _pof_ModelLoader : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ModelLoader() : _OMNI_NS(proxyObjectFactory)(ModelLoader::_PD_repoId) {}
    virtual ~_pof_ModelLoader();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ModelLoader :
    public virtual _impl_ServerObject
  {
  public:
    virtual ~_impl_ModelLoader();

    virtual BodyInfo_ptr getBodyInfo(const char* url) = 0;
    virtual BodyInfo_ptr getBodyInfoEx(const char* url, const ::OpenHRP::ModelLoader::ModelLoadOption& option) = 0;
    virtual BodyInfo_ptr loadBodyInfo(const char* url) = 0;
    virtual BodyInfo_ptr loadBodyInfoEx(const char* url, const ::OpenHRP::ModelLoader::ModelLoadOption& option) = 0;
    virtual SceneInfo_ptr loadSceneInfo(const char* url) = 0;
    virtual void clearData() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


_CORBA_MODULE_END



_CORBA_MODULE POA_OpenHRP
_CORBA_MODULE_BEG

  class ShapeSetInfo :
    public virtual OpenHRP::_impl_ShapeSetInfo,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~ShapeSetInfo();

    inline ::OpenHRP::ShapeSetInfo_ptr _this() {
      return (::OpenHRP::ShapeSetInfo_ptr) _do_this(::OpenHRP::ShapeSetInfo::_PD_repoId);
    }
  };

  class BodyInfo :
    public virtual OpenHRP::_impl_BodyInfo,
    public virtual ShapeSetInfo
  {
  public:
    virtual ~BodyInfo();

    inline ::OpenHRP::BodyInfo_ptr _this() {
      return (::OpenHRP::BodyInfo_ptr) _do_this(::OpenHRP::BodyInfo::_PD_repoId);
    }
  };

  class SceneInfo :
    public virtual OpenHRP::_impl_SceneInfo,
    public virtual ShapeSetInfo
  {
  public:
    virtual ~SceneInfo();

    inline ::OpenHRP::SceneInfo_ptr _this() {
      return (::OpenHRP::SceneInfo_ptr) _do_this(::OpenHRP::SceneInfo::_PD_repoId);
    }
  };

  class ModelLoader :
    public virtual OpenHRP::_impl_ModelLoader,
    public virtual ServerObject
  {
  public:
    virtual ~ModelLoader();

    inline ::OpenHRP::ModelLoader_ptr _this() {
      return (::OpenHRP::ModelLoader_ptr) _do_this(::OpenHRP::ModelLoader::_PD_repoId);
    }
  };

_CORBA_MODULE_END



_CORBA_MODULE OBV_OpenHRP
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

inline void operator >>=(OpenHRP::LightType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (OpenHRP::LightType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= OpenHRP::SPOT) {
    _e = (OpenHRP::LightType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

inline void operator >>=(OpenHRP::ShapePrimitiveType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (OpenHRP::ShapePrimitiveType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= OpenHRP::SP_PLANE) {
    _e = (OpenHRP::ShapePrimitiveType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

inline void operator >>=(OpenHRP::ModelLoader::AABBdataType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (OpenHRP::ModelLoader::AABBdataType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= OpenHRP::ModelLoader::AABB_NUM) {
    _e = (OpenHRP::ModelLoader::AABBdataType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}



inline void
OpenHRP::ShapeSetInfo::_marshalObjRef(::OpenHRP::ShapeSetInfo_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
OpenHRP::BodyInfo::_marshalObjRef(::OpenHRP::BodyInfo_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
OpenHRP::SceneInfo::_marshalObjRef(::OpenHRP::SceneInfo_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
OpenHRP::ModelLoader::_marshalObjRef(::OpenHRP::ModelLoader_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}




#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_ModelLoader
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_ModelLoader
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_ModelLoader
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_ModelLoader
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_ModelLoader
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_ModelLoader
#endif

#endif  // __ModelLoader_hh__

